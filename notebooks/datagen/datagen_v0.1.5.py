# -*- coding: utf-8 -*-
"""datagen.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z17lL9ChxbC_V_DmNlc9eOoN-WFsdgcO

### Generate Database with 6*6 images

shapes : square, triangle, cirle
colors : light red, light blue, light yellow, light green

dataset size : 2 000 000

probability to have a symbol at each position : 0.5

Same as v0.1.2 but with 2 millions images and with making sure there isn't any duplicates while generating the DB.
"""

from pathlib import Path
import os
os.environ["DATA"] = os.path.expanduser("~/data/")
db_dir = os.environ["DATA"] + "PatImgXAI_data/db0.1.5_6x6/"
os.makedirs(db_dir, exist_ok=True)

"""**Content of the database**\
param db = python dict used to store the information of image
To generate the images, the user must specify their content represented in a structured format (python dict or json file).
"""


"""###Load and Save Database
"""
from xaipatimg.datagen.dbimg import load_db
db = load_db(db_dir)

print(db)

"""Define number of image generation and grid"""

import numpy as np

# Number of images generated
NBGEN = 2000000

# Grid division of each image
X_DIVISIONS = 6
Y_DIVISIONS = 6

# Size of the images in pixels
img_size = (700, 700)

# Probability to generate a geometrical shape at each position in the grid
SHAPE_PROB = 0.5

# Define available shapes
SHAPES = ['circle', 'square', 'triangle']
COLORS  = ["#F86C62", "#7AB0CD", "#F4D67B", "#87C09C"]

import numpy as np
from xaipatimg.datagen.dbimg import generate_uuid
import os

to_generate = NBGEN
unique_content_generated = {}
duplicate_count = 0
while to_generate > 0:
    content = []
    for i in range(X_DIVISIONS):
        for j in range(Y_DIVISIONS):
            if np.random.random() < SHAPE_PROB:
                content.append({
                    "shape": np.random.choice(SHAPES),
                    "pos": (i, j),
                    "color": np.random.choice(COLORS)
                })

    if str(content) in unique_content_generated:
        duplicate_count += 1
        continue

    imgid = generate_uuid()
    db[imgid] = {
        "path": os.path.join("img", imgid + ".png"),
        "division" : (X_DIVISIONS, Y_DIVISIONS),
        "size": img_size,
        "content": content
    }

    unique_content_generated[str(content)] = True
    to_generate -= 1

print("unique generated in DB : " + str(len(db)))
print("duplicates avoided : " + str(duplicate_count))

"""Validating no duplicate is found"""

import tqdm

content_dict = {}
nb_duplicates = 0

for k, v in tqdm.tqdm(db.items()):
    if str(v["content"]) in content_dict:
        nb_duplicates += 1
    else:
        content_dict[str(v["content"])] = True

print(nb_duplicates)

    
from xaipatimg.datagen.genimg import gen_img_and_save_db
gen_img_and_save_db(db, db_dir, overwrite=False, n_jobs=190)


"""## Create Dataset
rules: at least one row contains only circle, and if row 2 contains red symbols if it does rule 1 applies otherwise rule 2 applies
"""
import csv
import json

"""Define Rules and generate dataset"""

"""
Create a dataset where there is at least one row that only contains circles
"""
def row_only_circles_rule(img_content):
    rows_with_shapes = {}
    for c in img_content:
      #pos is stored as (column,row)
        row = c['pos'][1]
        if row not in rows_with_shapes:
            rows_with_shapes[row] = []
        rows_with_shapes[row].append(c['shape'])

    for row in rows_with_shapes:
        shapes = rows_with_shapes[row]
        if all(shape == 'circle' for shape in shapes):
            return True

    return False

from xaipatimg.datagen.gendataset import create_dataset_based_on_rule
import os
csv_only_circle_train = "onlycircle_train.csv"
csv_only_circle_test = "onlycircle_test.csv"
csv_only_circle_valid = "onlycircle_valid.csv"
sample_img_path = os.path.join(db_dir, "datasets", "onlycircle_train")
create_dataset_based_on_rule(db_dir, csv_only_circle_train, csv_only_circle_test, csv_only_circle_valid, test_size=4000, valid_size=4000,
                             dataset_pos_samples_nb=12000, dataset_neg_samples_nb=12000, rule_fun=row_only_circles_rule)

"""
Create a dataset where If row 2 contains at least one red symbol, Rule 1 applies; otherwise, Rule 2 applies:
Rule 1: The number of triangles is greater than or equal to the number of blue symbols.
Rule 2: The number of green symbols is greater than or equal to the number of squares.
"""
def red_in_row_2_rule(img_content):
    red_in_row_2 = False
    #find if row 2 contains any red symbols
    for c in img_content:
        if c['pos'][1] == 1 and c['color'] == "#F86C62":
            red_in_row_2 = True
            break

    if red_in_row_2:
        # Rule 1
        nb_triangles = 0
        nb_blue = 0
        for c in img_content:
            if c['shape'] == 'triangle':
                nb_triangles += 1
            if c['color'] == "#7AB0CD":
                nb_blue += 1
        return nb_triangles >= nb_blue
    else:
        # Rule 2
        nb_green = 0
        nb_squares = 0
        for c in img_content:
            if c['color'] == "#87C09C":
                nb_green += 1
            if c['shape'] == 'square':
                nb_squares += 1
        return nb_green >= nb_squares

csv_red_in_row_2_train = "red_in_row_2_train.csv"
csv_red_in_row_2_test = "red_in_row_2_test.csv"
csv_red_in_row_2_valid = "red_in_row_2_valid.csv"
sample_img_path = os.path.join(db_dir, "datasets", "red_in_row_2_train")
create_dataset_based_on_rule(db_dir, csv_red_in_row_2_train, csv_red_in_row_2_test, csv_red_in_row_2_valid, test_size=4000, valid_size=4000,
                             dataset_pos_samples_nb=12000, dataset_neg_samples_nb=12000, rule_fun=red_in_row_2_rule)


"""Extract sample"""
from xaipatimg.datagen.gendataset import extract_sample_from_dataset

sample_img_path = os.path.join(db_dir, "datasets", "only_circle_train")
extract_sample_from_dataset(db_dir, csv_only_circle_train, output_dir_path=sample_img_path, pos_samples_nb=20, neg_samples_nb=20)

sample_img_path = os.path.join(db_dir, "datasets", "red_in_row2_train")
extract_sample_from_dataset(db_dir, csv_red_in_row_2_train, output_dir_path=sample_img_path, pos_samples_nb=20, neg_samples_nb=20)

